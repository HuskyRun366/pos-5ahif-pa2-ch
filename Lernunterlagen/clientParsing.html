<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binary-Tree Parser & Interpreter – interaktive Lernunterlage</title>
  <style>
    :root { --pad: 12px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; line-height: 1.35; }
    header { padding: 18px 16px; border-bottom: 1px solid #ddd; }
    main { display: grid; grid-template-columns: 1.1fr 1fr; gap: 12px; padding: 12px 16px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: var(--pad); background: #fff; }
    h1 { margin: 0 0 8px 0; font-size: 20px; }
    h2 { margin: 0 0 10px 0; font-size: 16px; }
    p { margin: 8px 0; }
    code, pre, textarea, input { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    pre { margin: 0; padding: 10px; border-radius: 8px; background: #f6f6f6; overflow: auto; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: end; }
    .row > * { flex: 1; min-width: 180px; }
    label { font-size: 12px; color: #333; display: block; margin-bottom: 6px; }
    input, textarea { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; }
    textarea { min-height: 70px; resize: vertical; }
    button { padding: 10px 12px; border-radius: 8px; border: 1px solid #bbb; background: #fafafa; cursor: pointer; }
    button:hover { background: #f1f1f1; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .btns { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    .muted { color: #555; font-size: 13px; }
    .ok { color: #0a7; }
    .err { color: #b00; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 980px) { .grid2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
<header>
  <h1>Binärbaum (AST) + ParserState + Auswertung (Interpreter) — interaktiv</h1>
  <p class="muted">
    Gib einen Ausdruck ein, klicke <b>Tokenize</b>, <b>Parse</b>, <b>Evaluate</b>.
    Du siehst: Tokens → ParserState(Position) → AST als Binärbaum → Auswertung mit Trace.
  </p>
</header>

<main>
  <section class="card">
    <h2>1) Kurz erklärt</h2>
    <p><b>Was ist der binäre Baum?</b> Ein Ausdruck wie <code>2 + 3 * 4</code> wird nicht „von links gerechnet“, sondern als Baum:</p>
    <pre>
    (+)
   /   \
 (2)   (*)
      /   \
    (3)   (4)
</pre>
    <p><b>Warum?</b> Damit Prioritäten automatisch stimmen: <code>*</code> sitzt tiefer im Baum als <code>+</code>.</p>

    <p><b>ParserState</b> ist nur „Tokens + Zeiger“:</p>
    <pre>
tokens = [2, +, 3, *, 4]
pos = 0
peek() -> tokens[pos]
next() -> tokens[pos++]   // konsumiert
</pre>

    <p><b>Parsing über Ebenen (Priorität)</b>:</p>
    <pre>
Expr   := Term   (('+'|'-') Term)*
Term   := Power  (('*'|'/') Power)*
Power  := Factor ('^' Power)?      // rechtsassoziativ
Factor := NUMBER | IDENT | '(' Expr ')'
</pre>

    <p class="muted">Das Muster „jede Ebene parst die stärkere Ebene“ ist genau das, was du mit deinen Nodes machst.</p>
  </section>

  <section class="card">
    <h2>2) Interaktiv ausprobieren</h2>

    <div class="row">
      <div>
        <label>Ausdruck</label>
        <input id="expr" value="2 + 3 * (4 + 1) ^ 2" />
        <div class="muted">Operatoren: <code>+ - * / ^</code>, Klammern, Variablen wie <code>x</code></div>
      </div>
      <div>
        <label>Variablen (optional)</label>
        <input id="vars" value="x=10,y=3" />
        <div class="muted">Format: <code>x=10,y=3</code> (leer lassen wenn keine)</div>
      </div>
    </div>

    <div class="btns">
      <button id="btnToken">Tokenize</button>
      <button id="btnParse" disabled>Parse (AST bauen)</button>
      <button id="btnEval" disabled>Evaluate (auswerten)</button>
      <button id="btnStep" disabled>Step durch Parse-Log</button>
      <button id="btnReset">Reset</button>
    </div>

    <p id="status" class="muted"></p>

    <div class="grid2" style="margin-top: 10px;">
      <div class="card">
        <h2>Tokens</h2>
        <pre id="outTokens">(noch nichts)</pre>
      </div>
      <div class="card">
        <h2>ParserState + Parse-Log</h2>
        <pre id="outLog">(noch nichts)</pre>
      </div>
    </div>

    <div class="grid2" style="margin-top: 12px;">
      <div class="card">
        <h2>AST als Binärbaum (ASCII)</h2>
        <pre id="outTree">(noch nichts)</pre>
      </div>
      <div class="card">
        <h2>Auswertung (Eval-Trace)</h2>
        <pre id="outEval">(noch nichts)</pre>
      </div>
    </div>
  </section>
</main>

<script>
/* =========================
   0) Tokenizer
========================= */
function tokenize(input) {
  const tokens = [];
  let i = 0;

  const isWS = c => /\s/.test(c);
  const isDigit = c => /[0-9]/.test(c);
  const isAlpha = c => /[A-Za-z_]/.test(c);
  const isAlnum = c => /[A-Za-z0-9_]/.test(c);

  while (i < input.length) {
    const c = input[i];
    if (isWS(c)) { i++; continue; }

    // number (int/float)
    if (isDigit(c) || (c === "." && isDigit(input[i+1] || ""))) {
      let start = i;
      i++;
      while (i < input.length && (isDigit(input[i]) || input[i] === ".")) i++;
      const raw = input.slice(start, i);
      const val = Number(raw);
      if (!Number.isFinite(val)) throw new Error("Ungültige Zahl: " + raw);
      tokens.push({ type: "NUMBER", value: val });
      continue;
    }

    // identifier
    if (isAlpha(c)) {
      let start = i;
      i++;
      while (i < input.length && isAlnum(input[i])) i++;
      const name = input.slice(start, i);
      tokens.push({ type: "IDENT", value: name });
      continue;
    }

    // operators / parens
    const single = { "+":"PLUS","-":"MINUS","*":"STAR","/":"SLASH","^":"CARET","(":"LPAREN",")":"RPAREN" };
    if (single[c]) {
      tokens.push({ type: single[c], value: c });
      i++;
      continue;
    }

    throw new Error("Unbekanntes Zeichen: " + c);
  }

  tokens.push({ type: "EOF", value: "<eof>" });
  return tokens;
}

/* =========================
   1) AST Nodes
========================= */
class NumberNode {
  constructor(value) { this.value = value; this.kind = "Number"; }
  eval(ctx, trace) { trace.push(`Number ${this.value}`); return this.value; }
}
class IdentNode {
  constructor(name) { this.name = name; this.kind = "Ident"; }
  eval(ctx, trace) {
    if (!(this.name in ctx)) throw new Error(`Variable '${this.name}' nicht gesetzt`);
    trace.push(`Ident ${this.name} -> ${ctx[this.name]}`);
    return ctx[this.name];
  }
}
class BinaryNode {
  constructor(op, left, right) { this.op = op; this.left = left; this.right = right; this.kind = "Binary"; }
  eval(ctx, trace) {
    trace.push(`Binary ${this.op} (enter)`);
    const a = this.left.eval(ctx, trace);
    const b = this.right.eval(ctx, trace);
    let r;
    switch (this.op) {
      case "+": r = a + b; break;
      case "-": r = a - b; break;
      case "*": r = a * b; break;
      case "/": r = a / b; break;
      case "^": r = Math.pow(a, b); break;
      default: throw new Error("Unbekannter Operator: " + this.op);
    }
    trace.push(`Binary ${this.op}: ${a} ${this.op} ${b} = ${r}`);
    return r;
  }
}
class UnaryNode {
  constructor(op, expr) { this.op = op; this.expr = expr; this.kind = "Unary"; }
  eval(ctx, trace) {
    trace.push(`Unary ${this.op} (enter)`);
    const v = this.expr.eval(ctx, trace);
    const r = this.op === "-" ? -v : v;
    trace.push(`Unary ${this.op}: ${this.op}${v} = ${r}`);
    return r;
  }
}

/* =========================
   2) ParserState
========================= */
class ParserState {
  constructor(tokens) { this.tokens = tokens; this.pos = 0; this.log = []; }
  peek() { return this.tokens[this.pos] || { type:"EOF", value:"<eof>" }; }
  next() {
    const t = this.peek();
    this.pos++;
    this.log.push(`next() -> ${t.type} '${t.value}' (pos=${this.pos})`);
    return t;
  }
  expect(type) {
    const t = this.peek();
    if (t.type !== type) throw new Error(`Erwartet ${type}, aber war ${t.type} '${t.value}' (pos=${this.pos})`);
    return this.next();
  }
  match(type) {
    if (this.peek().type === type) { this.next(); return true; }
    return false;
  }
}

/* =========================
   3) Recursive Descent Parser (Prioritäten)
   Expr -> Term -> Power -> Factor
========================= */

// Expr := Term (('+'|'-') Term)*
function parseExpr(st) {
  st.log.push(`parseExpr (pos=${st.pos})`);
  let node = parseTerm(st);
  while (st.peek().type === "PLUS" || st.peek().type === "MINUS") {
    const op = st.next().value;
    const right = parseTerm(st);
    node = new BinaryNode(op, node, right);
    st.log.push(`build Binary(${op})`);
  }
  return node;
}

// Term := Power (('*'|'/') Power)*
function parseTerm(st) {
  st.log.push(`parseTerm (pos=${st.pos})`);
  let node = parsePower(st);
  while (st.peek().type === "STAR" || st.peek().type === "SLASH") {
    const op = st.next().value;
    const right = parsePower(st);
    node = new BinaryNode(op, node, right);
    st.log.push(`build Binary(${op})`);
  }
  return node;
}

// Power := Factor ('^' Power)?  (rechtsassoziativ)
function parsePower(st) {
  st.log.push(`parsePower (pos=${st.pos})`);
  let node = parseFactor(st);
  if (st.peek().type === "CARET") {
    const op = st.next().value;
    const right = parsePower(st); // rechtsassoziativ
    node = new BinaryNode(op, node, right);
    st.log.push(`build Binary(${op}) [right-assoc]`);
  }
  return node;
}

// Factor := NUMBER | IDENT | '(' Expr ')' | unary +/- Factor
function parseFactor(st) {
  st.log.push(`parseFactor (pos=${st.pos})`);
  const t = st.peek();

  // unary +/-
  if (t.type === "PLUS" || t.type === "MINUS") {
    const op = st.next().value;
    const inner = parseFactor(st);
    st.log.push(`build Unary(${op})`);
    return op === "+" ? inner : new UnaryNode("-", inner);
  }

  if (t.type === "NUMBER") {
    st.next();
    return new NumberNode(t.value);
  }
  if (t.type === "IDENT") {
    st.next();
    return new IdentNode(t.value);
  }
  if (t.type === "LPAREN") {
    st.next();
    const node = parseExpr(st);
    st.expect("RPAREN");
    return node;
  }

  throw new Error(`Unerwartetes Token: ${t.type} '${t.value}' (pos=${st.pos})`);
}

/* =========================
   4) AST pretty print (ASCII tree)
========================= */
function treeToAscii(node, prefix = "", isTail = true) {
  const label =
    node.kind === "Binary" ? `(${node.op})` :
    node.kind === "Number" ? `${node.value}` :
    node.kind === "Ident" ? `${node.name}` :
    node.kind === "Unary" ? `(unary ${node.op})` :
    "(?)";

  let out = prefix + (isTail ? "└── " : "├── ") + label + "\n";

  const children = [];
  if (node.kind === "Binary") { children.push(node.left, node.right); }
  if (node.kind === "Unary") { children.push(node.expr || node.inner || node.right || node.left); } // fallback

  // UnaryNode stores expr in "expr"
  if (node.kind === "Unary") children[0] = node.expr;

  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    const last = i === children.length - 1;
    out += treeToAscii(child, prefix + (isTail ? "    " : "│   "), last);
  }
  return out;
}

/* =========================
   5) Vars parser: "x=10,y=3"
========================= */
function parseVars(s) {
  const ctx = {};
  const trimmed = (s || "").trim();
  if (!trimmed) return ctx;
  const parts = trimmed.split(",").map(x => x.trim()).filter(Boolean);
  for (const p of parts) {
    const m = p.match(/^([A-Za-z_]\w*)\s*=\s*(-?\d+(?:\.\d+)?)$/);
    if (!m) throw new Error("Variablenformat falsch bei: " + p + " (erwartet z.B. x=10)");
    ctx[m[1]] = Number(m[2]);
  }
  return ctx;
}

/* =========================
   6) UI wiring
========================= */
const elExpr = document.getElementById("expr");
const elVars = document.getElementById("vars");
const outTokens = document.getElementById("outTokens");
const outLog = document.getElementById("outLog");
const outTree = document.getElementById("outTree");
const outEval = document.getElementById("outEval");
const status = document.getElementById("status");
const btnToken = document.getElementById("btnToken");
const btnParse = document.getElementById("btnParse");
const btnEval = document.getElementById("btnEval");
const btnStep = document.getElementById("btnStep");
const btnReset = document.getElementById("btnReset");

let current = {
  tokens: null,
  st: null,
  ast: null,
  parseStepIndex: 0
};

function setStatus(msg, kind="muted") {
  status.className = kind;
  status.textContent = msg;
}

function resetAll() {
  current = { tokens: null, st: null, ast: null, parseStepIndex: 0 };
  outTokens.textContent = "(noch nichts)";
  outLog.textContent = "(noch nichts)";
  outTree.textContent = "(noch nichts)";
  outEval.textContent = "(noch nichts)";
  btnParse.disabled = true;
  btnEval.disabled = true;
  btnStep.disabled = true;
  setStatus("Bereit.", "muted");
}

btnReset.addEventListener("click", resetAll);

btnToken.addEventListener("click", () => {
  try {
    const tokens = tokenize(elExpr.value);
    current.tokens = tokens;
    outTokens.textContent = tokens.map((t, idx) => `${idx}: ${t.type} ${t.type==="NUMBER"||t.type==="IDENT" ? "(" + t.value + ")" : "'" + t.value + "'"}`).join("\n");
    btnParse.disabled = false;
    btnEval.disabled = true;
    btnStep.disabled = true;
    outLog.textContent = "(noch nicht geparsed)";
    outTree.textContent = "(noch nicht geparsed)";
    outEval.textContent = "(noch nicht ausgewertet)";
    setStatus("Tokenize OK. Jetzt Parse klicken.", "ok");
  } catch (e) {
    setStatus(e.message, "err");
  }
});

btnParse.addEventListener("click", () => {
  try {
    if (!current.tokens) throw new Error("Bitte zuerst Tokenize.");
    const st = new ParserState(current.tokens);
    const ast = parseExpr(st);
    st.expect("EOF"); // alles muss verbraucht sein

    current.st = st;
    current.ast = ast;
    current.parseStepIndex = 0;

    outLog.textContent = st.log.join("\n");
    outTree.textContent = treeToAscii(ast).trimEnd();

    btnEval.disabled = false;
    btnStep.disabled = false;
    setStatus("Parse OK. AST gebaut. Du kannst Evaluate oder Step klicken.", "ok");
  } catch (e) {
    setStatus(e.message, "err");
  }
});

btnEval.addEventListener("click", () => {
  try {
    if (!current.ast) throw new Error("Bitte zuerst Parse.");
    const ctx = parseVars(elVars.value);
    const trace = [];
    const value = current.ast.eval(ctx, trace);
    outEval.textContent = `Result = ${value}\n\nTrace:\n` + trace.join("\n");
    setStatus("Evaluate OK.", "ok");
  } catch (e) {
    setStatus(e.message, "err");
  }
});

btnStep.addEventListener("click", () => {
  try {
    if (!current.st) throw new Error("Bitte zuerst Parse.");
    const log = current.st.log;
    if (log.length === 0) return;
    current.parseStepIndex = Math.min(current.parseStepIndex + 1, log.length);
    const shown = log.slice(0, current.parseStepIndex);
    outLog.textContent = shown.join("\n") + (current.parseStepIndex < log.length ? "\n\n... (weiter mit Step)" : "\n\n(Ende)");
  } catch (e) {
    setStatus(e.message, "err");
  }
});

resetAll();
</script>
</body>
</html>
